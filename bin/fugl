#!/usr/bin/env node

const getStdin = require('get-stdin');
const wrap = require('@gustavnikolaj/async-main-wrap');
const yargs = require('yargs');

const cli = require('../src/cli');

const configureCheck = config => yargs =>
  yargs
    .config(config)
    .option('folder', {
      type: 'string',
      hidden: true
    })
    .option('package', {
      type: 'string',
      describe:
        'The package to install for testing: <packageName>@<packageVersion>'
    })
    .option('package-installer', {
      hidden: true,
      type: 'string',
      choices: ['npm', 'link', 'tarball'],
      describe: 'The strategy by which the supplied package should be installed'
    })
    .option('projects', {
      type: 'array',
      demandOption: true,
      describe: 'The projects depending on the package to be tested.'
    })
    .option('reporter', {
      type: 'string',
      describe: 'The name of the reporter to use for the output.'
    })
    .option('pretest', {
      type: 'boolean',
      describe:
        'Toggle whether the tests pass in a project prior to package installation.'
    })
    .option('pretest-or-ignore', {
      alias: 'pretestOrIgnore',
      type: 'boolean',
      describe:
        'Toggle whether to ignore a module package test on a pretest failure.'
    })
    .option('report-suffix', {
      alias: 'reportSuffix',
      type: 'string',
      describe:
        'An additional suffix to add to the default report output directory.'
    })
    .option('timeout', {
      type: 'number',
      describe:
        'Specify a timeout in ms that should apply to the installation phase; 0 will disable it completely.'
    })
    .option('quick', {
      type: 'boolean',
      describe:
        'Switch to allow fetching changes to project repositories instead of freshly cloning.'
    })
    .option('ci', {
      type: 'boolean',
      describe:
        'Switch to force output to the console to support running in CI.'
    });

const configureFetch = () => yargs =>
  yargs
    .option('package', {
      type: 'string',
      demandOption: true,
      describe: 'The package for which to fetch dependents.'
    })
    .positional('metric', {
      type: 'string',
      choices: ['downloads', 'stars'],
      demandOption: true,
      describe: 'The metric to use when ordering retrieved dependents.'
    })
    .option('librariesio', {
      type: 'string',
      describe: 'An API key for accessing dependents data via Libraries.IO.'
    });

const processArgv = config =>
  yargs
    .usage('$0 <cmd> [args]')
    .command(
      ['*', 'check'],
      'Run tests of the dependent projects checking for breakage.',
      configureCheck(config)
    )
    .command(
      'fetch <metric>',
      'Automatically find dependent projects to be checked.',
      configureFetch()
    )
    .help().argv;

const processStdinThenArgvAndExecute = cwd =>
  getStdin().then(value => {
    let config;
    if (value) {
      try {
        config = JSON.parse(value);
      } catch (e) {}

      if (!config) {
        // if not JSON then attempt to use stdin as bare projects
        const projects = value.split(' ');
        config = { projects };
      }
    }
    const argv = processArgv(config);
    const command = argv._[0] || 'check';

    return cli[command](cwd, argv);
  });

wrap(processStdinThenArgvAndExecute)(process.cwd());
